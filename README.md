# Recursive Yak Shaver (RYS)

**Recursive Yak Shaver (RYS)** は、曖昧な指示を具体的かつ安全なシェル操作に変換し、自動実行するマルチエージェント・パイプラインだ。Gemma-3N をコアに据え、翻訳・計画・実装・検証を自動で行う。

## 🚀 主要な特徴

- **6フェーズ・オートメーション**: ユーザーの自然言語入力を、翻訳、ディスパッチ、視覚化、計画、コーディング、実行の6段階で処理する。
- **Auto-Fix (Smart-Fix) エンジン**: LLMが生成しがちな `cut`, `head`, `tail` などのストリーム処理ミスを自動検知し、実行前に強制修正する。
- **ロールベース設計**: 翻訳者(Translater)、設計者(Engineer)、監査役(Auditor)など、専門特化したロールが協調して動作する。
- **多言語対応インターフェース**: `gemma` ロールにより、日本語・英語を問わず適切な言語で対話が可能。

## 🛠 ディレクトリ構造

```text
.
├── rys/                  # コア・ロジック
│   ├── main.bash         # メイン・エントリーポイント
│   ├── invoke_role.py    # ロール呼び出しハブ（デフォルト: gemma）
│   ├── phase1-6_*.py     # 各フェーズの実行スクリプト
│   └── ...
├── roles/                # ロール定義 (Markdown)
│   ├── role_gemma.md     # 汎用インターフェース（言語自動選択）
│   ├── role_coder.md     # コード生成の絶対ルール
│   └── role_common_constraints.md # 共通論理制約
├── config/               # 設定・スキル定義
│   ├── skills/           # shell_exec 等のチートシート
│   └── risks.json        # リスク回避知識ベース
└── tmp/                  # 実行時の中間成果物
```

## 📖 使い方

### 1. メインパイプラインの実行
自然言語で指示を出すだけで、必要なスクリプトが生成・実行される。
```bash
RYS_LLM_HOST=http://<IP> ./rys/main.bash "このディレクトリで一番大きいファイルを教えて"
```
`--auto` オプションを付けると、確認プロンプトをスキップして実行する。

#### キャッシュ制御と部分実行 (`--from`)
- `--from=N`: 指定したフェーズ $N$ から再開し、それ以降のキャッシュをすべて破棄して最後まで実行する。
- `--from=N,M`: 指定したフェーズのみキャッシュを破棄して実行し、リスト内の最大フェーズ完了後に自動停止する。
  - 例: `--from=4,4` (フェーズ4のみをやり直して停止)
  - 例: `--from=4,5` (フェーズ4と5をやり直して停止)

### 2. ロール単体での呼び出し
特定の役割としてLLMと対話する。デフォルトは `gemma` ロールで、挨拶や質問に簡潔に答える。
```bash
# 汎用挨拶（言語自動一致）
./rys/invoke_role.py --host=http://<IP> --prompt="hello"

# 特定の役割（エンジニア）を指名
./rys/invoke_role.py --role=engineer --prompt="Write a script to list files."
```

## 🛡 安全性と信頼性

- **Auditor Phase**: 生成されたプランは実行前に監査ロールによってリスクチェックを受ける。
- **Safe Stream Processing**: `$1` の誤用やファイルオープンミスをプログラムレベルでガードし、パイプラインの破綻を防ぐ。

## ⚖️ License
MIT License
