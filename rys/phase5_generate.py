#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Phase 5: Script Generation (v2.12)
Generates bash scripts for requests based on the I/O plan in TOON format.
1. 2026-02-17: Consolidated common logic into phase_utils.
"""

import sys
import os
import json
import argparse
from phase_utils import invoke_coder, prepare_coder_prompt, append_result_display

# pylint: disable=useless-return

# Add project root to path for utilities
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if SCRIPT_DIR not in sys.path:
    sys.path.append(SCRIPT_DIR)


def process_single_request(req, args, llm_config):
    """Processes one request: codes topics and writes the script."""
    req_id = req["request_id"]
    skill = req["skill"]

    print(f"Handling {req_id} ({skill})...")
    script_lines = ["#!/bin/bash", "# Generated by RYS Phase 5", ""]
    final_binding = None

    for topic in req["topics"]:
        print(f"  Coding {topic['id']}...")
        prompt = prepare_coder_prompt(topic)
        snippet = invoke_coder(SCRIPT_DIR, prompt, skill, llm_config)
        script_lines.append(f"# --- {topic['id']}: {topic['title']} ---")
        script_lines.append(snippet)
        script_lines.append("")
        if topic.get('output', {}).get('binding'):
            final_binding = topic['output']['binding']

    append_result_display(script_lines, req_id, final_binding)

    cache_dir = os.environ.get("RYS_CACHE_DIR", "./tmp")
    script_fn = f".rys.{args.uuid}.{req_id}.sh"
    script_path = os.path.abspath(os.path.join(cache_dir, script_fn))

    with open(script_path, "w", encoding="utf-8") as f_out:
        f_out.write("\n".join(script_lines))
    os.chmod(script_path, 0o755)

    return {"request_id": req_id, "path": script_path, "skill": skill}


def load_existing_scripts(out_json):
    """Loads previously generated scripts from output JSON."""
    existing = {}
    if os.path.exists(out_json):
        try:
            with open(out_json, 'r', encoding='utf-8') as f_in:
                old_data = json.load(f_in)
                for script in old_data.get("generated_scripts", []):
                    existing[script["request_id"]] = script
        except (json.JSONDecodeError, KeyError, OSError):
            pass
    return existing


def main():
    """Main execution for Phase 5 script generation."""
    parser = argparse.ArgumentParser()
    parser.add_argument("--in-json", required=True)
    parser.add_argument("--out-json", required=True)
    parser.add_argument("--uuid", required=True)
    parser.add_argument("--host", default="localhost")
    parser.add_argument("--port")
    parser.add_argument("--model", default="gemma3n:e4b")
    parser.add_argument("--request", help="Specific Request ID to regenerate")
    args = parser.parse_args()

    if not os.path.exists(args.in_json):
        sys.exit(1)

    with open(args.in_json, 'r', encoding='utf-8') as f_in:
        data = json.load(f_in)

    llm_config = {"host": args.host, "port": args.port, "model": args.model}
    existing_scripts = load_existing_scripts(args.out_json)
    script_list = []

    print(f">>> Phase 5: Generating Scripts (Session: {args.uuid})")

    for req in data.get("integrated_requests", []):
        req_id = req["request_id"]
        if req["skill"] == "IDONTKNOW":
            continue

        if args.request and req_id != args.request:
            if req_id in existing_scripts:
                print(f"Skipping {req_id} (Keeping existing script)")
                script_list.append(existing_scripts[req_id])
            continue

        script_list.append(process_single_request(req, args, llm_config))

    data["generated_scripts"] = script_list
    with open(args.out_json, "w", encoding="utf-8") as f_out:
        json.dump(data, f_out, indent=2)

    print(f"Phase 5 Complete. {len(script_list)} scripts tracked.\n")
    return


if __name__ == "__main__":
    main()
