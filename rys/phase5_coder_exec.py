#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Phase 5: Script Generation & Execution (v2.7)
Generates a complete bash script for a REQUEST based on the I/O plan in TOON format.
Ensures the final result of the REQUEST is displayed to the user.
"""

import sys
import os
import json
import argparse
import subprocess
import re

# Add project root to path for role_utils
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if SCRIPT_DIR not in sys.path:
    sys.path.append(SCRIPT_DIR)

from role_utils import format_as_toon

def resolve_refs(data):
    """Recursively replaces ref:TOPIC<N>.<binding> with $<binding>."""
    if isinstance(data, dict):
        return {k: resolve_refs(v) for k, v in data.items()}
    elif isinstance(data, list):
        return [resolve_refs(i) for i in data]
    elif isinstance(data, str):
        # Match ref:TOPIC<N>.<binding>
        return re.sub(r'ref:TOPIC\d+\.([a-zA-Z_0-9]+)', r'$\1', data)
    return data

def call_coder(topic, skill, host, port, model):
    """Calls the Coder role to get a code snippet for a topic following the I/O plan."""
    clean_input = resolve_refs(topic['input'])
    clean_output = resolve_refs(topic['output'])
    
    analysis_toon = format_as_toon("analysis", {
        "input": clean_input,
        "output": clean_output
    })
    
    prompt = f"### TASK\n{topic['raw']}\n\n"
    prompt += f"### ANALYSIS\n{analysis_toon}\n"
    
    cmd = [
        "python3", os.path.join(SCRIPT_DIR, "invoke_role.py"),
        "--role=coder",
        f"--prompt={prompt}",
        f"--skills={skill}",
        f"--host={host}",
        f"--model={model}",
        "--no-stream"
    ]
    if port:
        cmd.append(f"--port={port}")
        
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        out = result.stdout.strip()
        
        # Extract code block
        code_match = re.search(r"```(?:\w+)?\s*\n?(.*?)\n?```", out, re.DOTALL)
        if not code_match:
            if out and not ("Error" in out or "Connection" in out):
                snippet = out.strip()
            else:
                return f"# Error: No code block in LLM response\n# Response: {out[:100]}..."
        else:
            snippet = code_match.group(1).strip()
        
        clean_lines = []
        for line in snippet.splitlines():
            if line.startswith("# Processing:") or line.startswith("# Output Type:"):
                continue
            clean_lines.append(line)
        
        return "\n".join(clean_lines).strip()
    except Exception as e:
        return f"# Error calling coder LLM: {e}"

def main():
    parser = argparse.ArgumentParser(description="Phase 5: Script Generator")
    parser.add_argument("--request-json", required=True, help="Integrated Request JSON string")
    parser.add_argument("--auto", action="store_true", help="Execute generated script without confirmation")
    args = parser.parse_args()
    
    try:
        req = json.loads(args.request_json)
    except json.JSONDecodeError:
        sys.stderr.write("Invalid JSON data provided.\n")
        sys.exit(1)

    req_id = req.get("request_id", "UNKNOWN")
    skill = req.get("skill")
    topics = req.get("topics", [])
    
    host = os.environ.get("RYS_LLM_HOST", "localhost")
    port = os.environ.get("RYS_LLM_PORT", "11434")
    model = os.environ.get("RYS_LLM_MODEL", "gemma3n:e4b")

    print(f"==================================================")
    print(f">>> Phase 5: Generating Script for {req_id}")
    print(f"Skill: {skill}")
    print(f"--------------------------------------------------")

    script_lines = ["#!/bin/bash", "# Generated by RYS Phase 5", "set -e", ""]
    
    final_binding = None
    for topic in topics:
        print(f"Coding Topic: {topic['id']} ({topic['title']})...")
        snippet = call_coder(topic, skill, host, port, model)
        
        script_lines.append(f"# --- {topic['id']}: {topic['title']} ---")
        script_lines.append(snippet)
        script_lines.append("")
        
        # Keep track of the last binding defined
        output = topic.get('output', {})
        if isinstance(output, dict) and output.get('binding'):
            final_binding = output['binding']

    # Append result display section
    if final_binding:
        script_lines.append("# --- Final Result Display ---")
        script_lines.append(f"echo \"\"")
        script_lines.append(f"echo \"[RESULT: {req_id}]\"")
        script_lines.append(f"echo \"${final_binding}\"")
        script_lines.append(f"echo \"\"")

    full_script = "\n".join(script_lines)
    
    session_uuid = os.environ.get("RYS_UUID", "default")
    script_path = f"./tmp/.rys.{session_uuid}.{req_id}.sh"
    
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(full_script)
    os.chmod(script_path, 0o755)

    print(f"--------------------------------------------------")
    print(f"Generated Script: {script_path}")
    print(f"--------------------------------------------------")
    print(full_script)
    print(f"--------------------------------------------------")
    
    auto_mode = args.auto or (os.environ.get("RYS_AUTO", "").lower() == "true")
    if auto_mode:
        print("Auto-executing...")
        subprocess.run(script_path, shell=True)
    else:
        sys.stdout.write("Execute this script? [y/N]: ")
        sys.stdout.flush()
        choice = sys.stdin.readline().strip().lower()
        if choice == 'y':
            print(f"Running {script_path}...")
            subprocess.run(script_path, shell=True)
            print("Done.")

if __name__ == "__main__":
    main()
